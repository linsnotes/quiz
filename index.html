<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>Quiz Lah!</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <!-- KaTeX CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css"
          integrity="sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV"
          crossorigin="anonymous">

    <!-- KaTeX JS (defer recommended for better loading performance) -->
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"
            integrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8"
            crossorigin="anonymous"></script>

    <!-- Optional: KaTeX auto-render extension JS -->
    <!-- Assuming this hash was already correct, otherwise update it too -->
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"
            integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05"
            crossorigin="anonymous"></script>
    
    <style>
        :root {
            --primary-color: #0071e3;
            --error-color: #ff3b30;
            --success-color: #34c759;
            --gray-light: #f5f5f7;
            --gray-medium: #d2d2d7;
            --gray-dark: #86868b;
            --text-color: #1d1d1f;
            --background-color: #ffffff;
            --border-radius: 12px;
            --shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
            --transition: all 0.3s ease;
            --text-footer: #6b7280;
            --footer: #e5e7eb;
            --primary: #1a73e8; /* Modern blue color for gradient */
            --accent: #8b5cf6; /* Purple color for gradient */
            --dark: #111827;   /* Dark color for base h1 (if not overridden) */
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: -apple-system, BlinkMacSystemFont, 'San Francisco', 'Helvetica Neue', Helvetica, Arial, sans-serif;
        }

        body {
            background-color: var(--background-color);
            color: var(--text-color);
            line-height: 1.5;
            min-height: 100vh;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
            padding: 2rem 1rem;
        }

        header {
            text-align: center;
            margin-bottom: 2rem;
        }

        header.hidden {
            display: none;
        }

        .hidden {
            display: none;
        }

        h1 {
            /* These are from the shooter app, adjust if they conflict badly */
            /* color: var(--dark); /* Base color before gradient */
            font-size: 2rem;      /* Example size */
            margin-bottom: 1.5rem;/* Example margin */
            /* You might need to adjust text-align if your header isn't centered */
            text-align: center;
        }

        /* Rotating icon animation */
        .rotate-icon {
            display: inline-block;
            animation: spin 3s linear infinite;
            margin-right: 0.5rem; /* Add some space between icon and text */
            /* Adjust color if needed, FontAwesome default is usually fine */
            /* color: var(--primary); */
        }

        .icon {
            color: var(--primary);
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Text fill effect */
        .fill-text {
            display: inline-block; /* Important for background clip */
            background: linear-gradient(90deg, var(--primary), var(--accent));
            background-size: 200% 100%;
            -webkit-background-clip: text;
            background-clip: text; /* Standard property */
            color: transparent; /* Makes the text color invisible, showing the background */
            animation: fillText 5s ease infinite;
            font-style: italic;
        }

        @keyframes fillText {
            from { background-position: -100% 0; }
            to { background-position: 0 0; }
        }

    
        h2 {
            font-size: 1.5rem;
            font-weight: 500;
            margin-bottom: 1.5rem;
            letter-spacing: -0.01em;
            font-style: italic;
            color: #222222;
        }

        h3 {
            font-size: 1.25rem;
            font-weight: 500;
            margin-bottom: 1rem;
        }

        p {
            font-size: 1rem;
            margin-bottom: 1rem;
            color: var(--gray-dark);
        }

        .app-footer { margin-top: auto; text-align: center; padding: 1rem 0; font-size: 0.875rem; color: var(--text-footer); border-top: 1px solid var(--footer); }
        .app-footer a { color: #6b7280; text-decoration: none; }

        .screen {
            display: none;
            padding: 2rem;
            background-color: var(--background-color);
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
            animation: fadeIn 0.5s ease;
        }

        /* --- Styles for Built-in Quiz Selection --- */

        /* Style for the built-in quiz dropdown */
        #builtInQuizSelect {
            width: 100%;
            padding: 0.75rem 1rem; /* Consistent padding */
            font-size: 1rem;      /* Consistent font size */
            border: 1px solid var(--gray-medium);
            border-radius: var(--border-radius);
            background-color: var(--background-color); /* Use theme background */
            color: var(--text-color);          /* Use theme text color */
            appearance: none;                  /* Remove default OS styling */
            -webkit-appearance: none;          /* For Safari/Chrome */
            /* Custom dropdown arrow using SVG */
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%2386868b'%3E%3Cpath d='M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z'/%3E%3C/svg%3E"); /* Slightly darker gray arrow */
            background-repeat: no-repeat;
            background-position: right 0.75rem center; /* Position arrow */
            background-size: 1.25rem;             /* Size arrow */
            cursor: pointer;
            transition: var(--transition);
            margin-bottom: 1rem;
        }

        /* Focus style for the dropdown */
        #builtInQuizSelect:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 2px rgba(0, 113, 227, 0.3);
        }

        /* Style for disabled dropdown */
        #builtInQuizSelect:disabled {
            background-color: var(--gray-light);
            cursor: not-allowed;
            opacity: 0.7; /* Make it look visually disabled */
        }

        /* Style for the 'OR' divider */
        .welcome-divider {
            text-align: center;
            margin: 1.5rem 0; /* Space above and below */
            color: var(--gray-dark);
            font-weight: 500; /* Slightly bolder */
            font-size: 0.9rem; /* Slightly smaller */
        }
        /* --- End Styles for Built-in Quiz Selection --- */


        
        #resultScreen {
            animation: none !important;
        }

        .screen.active {
            display: block;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .input-group {
            margin-bottom: 1rem;
        }

        label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
        }

        input[type="text"] {
            width: 100%;
            padding: 0.75rem 1rem;
            font-size: 1rem;
            border: 1px solid var(--gray-medium);
            border-radius: var(--border-radius);
            transition: var(--transition);
        }

        input[type="text"]:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 2px rgba(0, 113, 227, 0.3);
        }

        .btn {
            display: inline-block;
            padding: 0.75rem 2rem;
            font-size: 1rem;
            font-weight: 500;
            text-align: center;
            text-decoration: none;
            background-color: var(--primary-color);
            color: white;
            border: none;
            border-radius: var(--border-radius);
            cursor: pointer;
            transition: var(--transition);
        }

        .btn:hover {
            background-color: #0058b0;
            transform: translateY(-2px);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn-secondary {
            background-color: var(--gray-light);
            color: var(--text-color);
        }

        .btn-secondary:hover {
            background-color: var(--gray-medium);
        }

        .btn-group {
            display: flex;
            gap: 1rem;
            margin-top: 2rem;
            flex-wrap: wrap;
            justify-content: center;
        }

        .center-btn {
            display: flex;
            justify-content: center;
            width: 100%;
        }

        .navigation-buttons {
            display: flex;
            justify-content: space-between;
            margin-top: 2rem;
        }

        .loading {
            text-align: center;
            padding: 2rem;
        }

        .spinner {
            display: inline-block;
            width: 50px;
            height: 50px;
            border: 4px solid rgba(0, 113, 227, 0.2);
            border-radius: 50%;
            border-top-color: var(--primary-color);
            animation: spin 1s linear infinite;
            margin-bottom: 1rem;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        .question-card {
            margin-bottom: 2rem;
        }

        .question-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }

        .question-number {
            font-size: 0.875rem;
            color: var(--gray-dark);
        }

        .timer {
            font-size: 0.875rem;
            color: var(--gray-dark);
        }

        .submit-wrapper {
            text-align: center;
        }

        .submit-header-btn {
            padding: 0.5rem 1rem;
            font-size: 0.875rem;
            border-radius: 20px;
        }

        .question-text {
            font-size: 1.25rem;
            font-weight: 500;
            margin-bottom: 1.5rem;
        }

        .reading-material {
            background-color: var(--gray-light);
            padding: 1rem;
            border-radius: var(--border-radius);
            margin-bottom: 1.5rem;
            font-style: normal;
            white-space: pre-line; /* <<<or use pre-wrap */
            text-align: justify;
        }

        .mcq-options {
            display: grid;
            gap: 1rem;
        }

        .mcq-option {
            display: flex;
            align-items: center;
            padding: 1rem;
            border: 1px solid var(--gray-medium);
            border-radius: var(--border-radius);
            cursor: pointer;
            transition: var(--transition);
        }

        .mcq-option:hover {
            background-color: var(--gray-light);
        }

        .mcq-option.selected {
            border-color: var(--primary-color);
            background-color: rgba(0, 113, 227, 0.1);
        }

        .mcq-option-letter {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 30px;
            height: 30px;
            background-color: var(--gray-light);
            border-radius: 50%;
            margin-right: 0.75rem;
            font-weight: 500;
        }

        .typing-answer {
            margin-top: 1rem;
        }

        .hint-container,
        .explanation-container {
            margin-top: 1.5rem;
            padding: 1rem;
            border-radius: var(--border-radius);
            background-color: var(--gray-light);
            display: none;
        }

        .hint-container.active,
        .explanation-container.active {
            display: block;
            animation: fadeIn 0.3s ease;
        }

        .result-summary {
            text-align: center;
            margin-bottom: 2rem;
        }

        .result-score {
            font-size: 3rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
            color: var(--primary-color);
        }

        .result-details {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1rem;
            margin-bottom: 2rem;
        }

        .result-detail-card {
            padding: 1.5rem;
            background-color: var(--gray-light);
            border-radius: var(--border-radius);
            text-align: center;
        }

        .result-detail-value {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
        }

        .result-detail-label {
            font-size: 0.875rem;
            color: var(--gray-dark);
        }

        .review-question {
            margin-bottom: 2rem;
            padding: 1.5rem;
            border-radius: var(--border-radius);
            background-color: var(--gray-light);
        }

        .review-question.correct {
            border-left: 4px solid var(--success-color);
        }

        .review-question.incorrect {
            border-left: 4px solid var(--error-color);
        }

        .review-answer {
            margin-top: 1rem;
            font-weight: 500;
        }

        .review-answer.correct {
            color: var(--success-color);
        }

        .review-answer.incorrect {
            color: var(--error-color);
        }

        .review-explanation {
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px solid var(--gray-medium);
            white-space: pre-line;
            text-align: justify;
        }

        /* Visitor counter styles */
        #visitor-counter {
            display: inline-block;
            margin: 0.5rem auto 1rem;
            padding: 0.4rem 1rem;
            background-color: var(--gray-light);
            border-radius: 20px;
            font-size: 0.875rem;
            color: var(--gray-dark);
            transition: var(--transition);
        }

        #pageviews {
            font-weight: 600;
            color: var(--primary-color);
            position: relative;
        }

        #pageviews.loading {
            animation: pulse 1.5s infinite ease-in-out;
            padding: 0;
            display: inline;
        }

        /* New style for submission notification */
        .submission-notification {
            background-color: var(--success-color);
            color: white;
            padding: 1rem;
            border-radius: var(--border-radius);
            margin-bottom: 1.5rem;
            text-align: center;
            animation: fadeIn 0.5s ease;
        }

        /* Add this rule */
        .submission-notification.error {
            background-color: var(--error-color); /* Use your theme's error color */
        }

        @keyframes pulse {
            0% {
                opacity: 0.6;
            }

            50% {
                opacity: 1;
            }

            100% {
                opacity: 0.6;
            }
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 2rem;
            }

            h2 {
                font-size: 1.5rem;
            }

            .container {
                padding: 1rem;
            }

            .screen {
                padding: 1.5rem;
            }

            /* Updated: Keep buttons in one row for mobile */
            .btn-group {
                flex-direction: row;
                flex-wrap: wrap;
                justify-content: center;
                gap: 0.5rem;
            }

            .btn {
                padding: 0.75rem 1rem;
                font-size: 0.875rem;
                white-space: nowrap;
                flex: 1 1 auto;
                min-width: 0;
            }

            /* Updated: Make quiz results more compact on mobile */
            .result-details {
                display: grid;
                grid-template-columns: repeat(2, 1fr);
                gap: 0.5rem;
            }

            .result-detail-card {
                padding: 0.75rem;
            }

            .result-detail-value {
                font-size: 1.25rem;
                margin-bottom: 0.25rem;
            }

            .result-detail-label {
                font-size: 0.75rem;
            }

            .question-header {
                flex-direction: column;
                align-items: flex-start;
                gap: 0.5rem;
            }

            .submit-wrapper {
                margin-top: 0.5rem;
                width: 100%;
            }

            .submit-header-btn {
                width: 100%;
            }

            /* Make navigation buttons stay in one row on mobile */
            .navigation-buttons {
                flex-direction: row;
                flex-wrap: wrap;
                gap: 0.5rem;
            }

            .navigation-buttons .btn {
                flex: 1;
                padding: 0.75rem 0.5rem;
                min-width: 0;
            }
        }

        #studentName {
            font-weight: 600;
        }
    </style>
</head>

<body>
    <div class="container">
        <header id="appHeader">
            <h1><i class="fas fa-pen-to-square icon"></i> <!-- add rotate-icon to rotate --> 
                <span class="fill-text">Quiz Lah !</span>
            </h1>
            

            <p>This website runs entirely in your web browser. No personal data is collected or stored on any server.
                Your name is used solely for your quiz summary and is removed when you refresh the page.</p>
        </header>

        <div id="welcomeScreen" class="screen active">
            <h2>Think you know? Come Quiz Lah!</h2>
            <div class="input-group">
                <label for="nameInput">Your Name</label>
                <input type="text" id="nameInput" placeholder="Enter your name">
            </div>

             <!-- Built-in Quiz Selection -->
            <div class="input-group">
                <label for="builtInQuizSelect">Select a Built-in Quiz:</label>
                <select id="builtInQuizSelect" class="form-control"> <!-- Removed inline style, uses CSS now -->
                    <option value="" disabled selected>-- Loading quizzes... --</option>
                    <!-- Quiz options will be loaded here by JavaScript -->
                </select>
                <!-- Added a dedicated container div for the button with a class -->
                <div class="center-btn">
                     <button id="startBuiltInQuizBtn" class="btn" disabled>Start Selected Quiz</button>
                </div>
            </div>

            <!-- Divider -->
            <div class="welcome-divider">OR</div> <!-- Use the CSS class for styling -->
           
            <!-- Custom Quiz ID Input -->
            <div class="input-group">
                <label for="sheetIdInput">Enter Custom Quiz ID:</label>
                        <p style="margin-top: 0.25rem; margin-bottom: 0.5rem; color: var(--text-secondary); font-size: 0.875rem;"><i class="fas fa-info-circle"></i> Quiz ID is provided by your teacher</p>
                <input type="text" id="sheetIdInput" placeholder="Enter a specific Quiz ID">

            </div>
            <div class="center-btn"> <!-- Keep existing centering -->
                <button id="startCustomQuizBtn" class="btn">Start Custom Quiz</button> <!-- ID and Text Changed -->
            </div>

        </div>

        <!-- New screen for Result Submission input -->
        <div id="webAppLinkScreen" class="screen">
            <h2>Submit Quiz Results</h2>
            <p>If your teacher provided a Submission ID, you can submit your quiz results directly to them.</p>
            <div class="input-group">
                <!-- CHANGE Label Text -->
                <label for="webAppLinkInput">Submission ID (Optional)</label>
                <!-- CHANGE Placeholder Text -->
                <input type="text" id="webAppLinkInput" placeholder="Enter Submission ID provided by teacher">
                <!-- CHANGE Paragraph Text -->
                <p>This ID will be used to send your quiz results to your teacher.</p>
            </div>
            <div class="btn-group">
                <button id="skipWebAppLinkBtn" class="btn btn-secondary">Skip</button>
                <button id="confirmWebAppLinkBtn" class="btn" disabled>OK</button>
            </div>
        </div>

        <div id="loadingScreen" class="screen">
            <div class="loading">
                <div class="spinner"></div>
                <p>Loading questions...</p>
            </div>
        </div>

        <div id="questionScreen" class="screen">
            <div class="question-header">
                <div class="question-number">Question <span id="currentQuestionNumber">1</span> of <span
                        id="totalQuestions">10</span></div>
                <div class="submit-wrapper">
                    <button id="submitAllBtn" class="btn submit-header-btn">Submit All Answers</button>
                </div>
                <div class="timer">Time: <span id="timerValue">00:00</span></div>
            </div>
            <div class="question-card">
                <div id="readingMaterial" class="reading-material" style="display: none;"></div>
                <div id="questionText" class="question-text"></div>
                <div id="mcqOptions" class="mcq-options"></div>
                <div id="typingAnswer" class="typing-answer" style="display: none;">
                    <input type="text" id="answerInput" placeholder="Type your answer here">
                </div>
                <div id="hintContainer" class="hint-container">
                    <h3>Hint:</h3>
                    <p id="hintText"></p>
                </div>
                <div class="navigation-buttons">
                    <button id="prevQuestionBtn" class="btn btn-secondary">Previous</button>
                    <button id="showHintBtn" class="btn btn-secondary">Show Hint</button>
                    <button id="nextQuestionBtn" class="btn btn-secondary">Next</button>
                </div>
            </div>
        </div>

        <div id="resultScreen" class="screen">
            <div id="submissionNotification" class="submission-notification" style="display: none;">
                Quiz data has been submitted to teacher.
            </div>
            <div class="result-summary">
                <h2>Quiz Results</h2>
                <p>Well done, <span id="studentName"></span>!</p>
                <div class="result-score"><span id="correctAnswers">0</span>/<span id="totalQuestionsResult">0</span>
                </div>
            </div>
            <div class="result-details">
                <div class="result-detail-card">
                    <div class="result-detail-value" id="totalQuestionsAttempted">0</div>
                    <div class="result-detail-label">Questions Attempted</div>
                </div>
                <div class="result-detail-card">
                    <div class="result-detail-value" id="correctAnswersCount">0</div>
                    <div class="result-detail-label">Correct Answers</div>
                </div>
                <div class="result-detail-card">
                    <div class="result-detail-value" id="incorrectAnswersCount">0</div>
                    <div class="result-detail-label">Incorrect Answers</div>
                </div>
                <div class="result-detail-card">
                    <div class="result-detail-value" id="timeSpent">00:00</div>
                    <div class="result-detail-label">Time Spent</div>
                </div>
            </div>
            <div class="btn-group">
                <button id="screenshotBtn" class="btn">Screenshot Result</button>
                <button id="reviewBtn" class="btn">Review All Questions</button>
                <button id="homeBtn" class="btn">Back to Home</button>
            </div>
        </div>

        <div id="reviewScreen" class="screen">
            <h2>Review All Questions</h2>
            <div id="reviewContainer"></div>
            <div class="btn-group">
                <button id="backToResultsBtn" class="btn">Back to Results</button>
                <button id="reviewHomeBtn" class="btn">Back to Home</button>
            </div>
        </div>
        <footer class="app-footer" id="appFooter">
            <div id="visitor-counter">
                <span>Welcome!</span> <span id="pageviews" class="loading">Loading...</span> <span>visits</span>
            </div>
            <p><a href="https://linsnotes.com">linsnotes.com</a></p>
        </footer>
    </div>
     <!-- Scripts -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script data-goatcounter="https://linsnotes.goatcounter.com/count" async src="https://gc.zgo.at/count.js"></script>

    <script>
        let enableSubmissionIdScreen = false; 
       // DOM Elements
        const appHeader = document.getElementById('appHeader');
        const appFooter = document.getElementById('appFooter');
        const welcomeScreen = document.getElementById('welcomeScreen');
        const loadingScreen = document.getElementById('loadingScreen');
        const questionScreen = document.getElementById('questionScreen');
        const resultScreen = document.getElementById('resultScreen');
        const reviewScreen = document.getElementById('reviewScreen');

        // DOM elements for built-in quiz selection
        const builtInQuizSelect = document.getElementById('builtInQuizSelect');
        const startBuiltInQuizBtn = document.getElementById('startBuiltInQuizBtn');
        const startCustomQuizBtn = document.getElementById('startCustomQuizBtn');


        
        // New DOM elements for Web App link screen
        const webAppLinkScreen = document.getElementById('webAppLinkScreen');
        const webAppLinkInput = document.getElementById('webAppLinkInput');
        const skipWebAppLinkBtn = document.getElementById('skipWebAppLinkBtn');
        const confirmWebAppLinkBtn = document.getElementById('confirmWebAppLinkBtn');
        const submissionNotification = document.getElementById('submissionNotification');

        const nameInput = document.getElementById('nameInput');
        const sheetIdInput = document.getElementById('sheetIdInput');

        const currentQuestionNumber = document.getElementById('currentQuestionNumber');
        const totalQuestions = document.getElementById('totalQuestions');
        const timerValue = document.getElementById('timerValue');
        const readingMaterial = document.getElementById('readingMaterial');
        const questionText = document.getElementById('questionText');
        const mcqOptions = document.getElementById('mcqOptions');
        const typingAnswer = document.getElementById('typingAnswer');
        const answerInput = document.getElementById('answerInput');
        const prevQuestionBtn = document.getElementById('prevQuestionBtn');
        const nextQuestionBtn = document.getElementById('nextQuestionBtn');
        const showHintBtn = document.getElementById('showHintBtn');
        const submitAllBtn = document.getElementById('submitAllBtn');
        const hintContainer = document.getElementById('hintContainer');
        const hintText = document.getElementById('hintText');

        const studentName = document.getElementById('studentName');
        const totalQuestionsResult = document.getElementById('totalQuestionsResult');
        const totalQuestionsAttempted = document.getElementById('totalQuestionsAttempted');
        const correctAnswers = document.getElementById('correctAnswers');
        const correctAnswersCount = document.getElementById('correctAnswersCount');
        const incorrectAnswersCount = document.getElementById('incorrectAnswersCount');
        const timeSpent = document.getElementById('timeSpent');
        const screenshotBtn = document.getElementById('screenshotBtn');
        const reviewBtn = document.getElementById('reviewBtn');
        const homeBtn = document.getElementById('homeBtn');

        const reviewContainer = document.getElementById('reviewContainer');
        const backToResultsBtn = document.getElementById('backToResultsBtn');
        const reviewHomeBtn = document.getElementById('reviewHomeBtn');

        // App State
        const WEB_APP_BASE_URL = 'https://script.google.com/macros/s/';
        const WEB_APP_URL_SUFFIX = '/exec';
        let questions = [];
        let currentQuestion = 0;
        let startTime;
        let timerInterval;
        let userAnswers = [];
        let quizCompleted = false;
        let hintVisible = false;
        let quizTimeLimit = null; // Global time limit in minutes
        // New state variable for submission ID link
        let submissionId = null;
        const QUIZ_LIST_SHEET_ID = '1pNzZ1Kpz4hprwLb412eN7dmMl99rB1Z4m1MZVFVkFlA';
        let builtInQuizzes = []; // To store the loaded list

        // Event Listeners
        startBuiltInQuizBtn.addEventListener('click', startBuiltInQuiz);
        startCustomQuizBtn.addEventListener('click', startCustomQuiz);
        prevQuestionBtn.addEventListener('click', showPreviousQuestion);
        nextQuestionBtn.addEventListener('click', showNextQuestion);
        showHintBtn.addEventListener('click', toggleHint);
        submitAllBtn.addEventListener('click', submitAllAnswers);
        screenshotBtn.addEventListener('click', takeScreenshot);
        reviewBtn.addEventListener('click', showReviewScreen);
        homeBtn.addEventListener('click', goToHome);
        backToResultsBtn.addEventListener('click', backToResults);
        reviewHomeBtn.addEventListener('click', goToHome);
        // New event listeners for Web App link handling
        skipWebAppLinkBtn.addEventListener('click', skipWebAppLink);
        confirmWebAppLinkBtn.addEventListener('click', confirmWebAppLink);
        webAppLinkInput.addEventListener('input', validateWebAppLink);

        builtInQuizSelect.addEventListener('change', () => {
            // Enable the button only if a valid quiz (not the default placeholder) is selected
            startBuiltInQuizBtn.disabled = !builtInQuizSelect.value;
            // Optionally, clear the custom ID field when a built-in quiz is selected
            sheetIdInput.value = '';
        });

        sheetIdInput.addEventListener('input', () => {
            if (sheetIdInput.value.trim() !== '') {
                builtInQuizSelect.selectedIndex = 0; // Reset dropdown to "-- Select a Quiz --"
                startBuiltInQuizBtn.disabled = true; // Disable the built-in start button
            }
        });

        
        // Add global event listener for answer input
        answerInput.addEventListener('input', function() {
            if (currentQuestion < questions.length) {
                saveUserAnswer(this.value);
            }
        });


        /**
         * Fetches the list of built-in quizzes from the specified Google Sheet.
         */
        async function loadBuiltInQuizList() {
            const selectElement = builtInQuizSelect;
            selectElement.disabled = true; // Disable while loading
            selectElement.options[0].text = "-- Loading quizzes... --"; // Update placeholder text
            startBuiltInQuizBtn.disabled = true;

            if (!QUIZ_LIST_SHEET_ID || QUIZ_LIST_SHEET_ID === 'YOUR_QUIZ_LIST_SHEET_ID_HERE') {
                 console.error("Quiz List Sheet ID is not set. Please update the QUIZ_LIST_SHEET_ID constant.");
                 selectElement.options[0].text = "-- Error: Quiz List ID not set --";
                 return;
            }

            const url = `https://docs.google.com/spreadsheets/d/${QUIZ_LIST_SHEET_ID}/export?format=xlsx`;

            try {
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`Failed to fetch quiz list spreadsheet (Status: ${response.status})`);
                }

                const arrayBuffer = await response.arrayBuffer();
                const data = new Uint8Array(arrayBuffer);
                const workbook = XLSX.read(data, { type: 'array' });

                const firstSheetName = workbook.SheetNames[0];
                const worksheet = workbook.Sheets[firstSheetName];
                // Read sheet into an array of arrays, getting raw values
                const rows = XLSX.utils.sheet_to_json(worksheet, { header: 1, raw: true });

                if (!rows || rows.length < 1) { // Allow empty sheet, just show no quizzes
                    builtInQuizzes = [];
                } else {
                     // Expecting Col A (index 0) = Name, Col B (index 1) = ID
                     // Filter out rows where name or ID might be missing or empty
                     // Also skip header row if present (simple check: if first row looks like headers, e.g., contains 'Name' or 'ID')
                     let dataRows = rows;
                     if (rows.length > 0 && (String(rows[0][0]).toLowerCase().includes('name') || String(rows[0][1]).toLowerCase().includes('id'))) {
                         dataRows = rows.slice(1); // Skip header row
                     }

                     builtInQuizzes = dataRows
                         .map(row => ({
                             title: row[0] ? String(row[0]).trim() : '', // Get Name from Col A
                             id: row[1] ? String(row[1]).trim() : ''    // Get ID from Col B
                         }))
                         .filter(quiz => quiz.title && quiz.id); // Keep only rows with both valid title and ID
                }

                populateBuiltInQuizDropdown(builtInQuizzes);

            } catch (error) {
                console.error('Error loading built-in quiz list:', error);
                selectElement.options[0].text = "-- Error loading quizzes --";
                 alert(`Error loading the list of built-in quizzes. Please check the QUIZ_LIST_SHEET_ID (${QUIZ_LIST_SHEET_ID}) and network connection. Details: ${error.message}`);
            } finally {
                 // Re-enable select only if there are quizzes loaded
                 // Keep it disabled if list is empty or loading failed
                 selectElement.disabled = builtInQuizzes.length === 0;
            }
        }

        /**
         * Populates the dropdown menu with the loaded list of built-in quizzes.
         * @param {Array<{title: string, id: string}>} quizList - The list of quizzes.
         */
        function populateBuiltInQuizDropdown(quizList) {
            const selectElement = builtInQuizSelect;
            selectElement.innerHTML = ''; // Clear existing options (including the loading message)

            // Add the default, non-selectable option
            const defaultOption = document.createElement('option');
            defaultOption.value = "";
            defaultOption.textContent = "-- Select a Quiz --";
            defaultOption.disabled = true;
            defaultOption.selected = true;
            selectElement.appendChild(defaultOption);

            if (quizList.length === 0) {
                defaultOption.textContent = "-- No built-in quizzes found --";
                selectElement.disabled = true;
                startBuiltInQuizBtn.disabled = true;
            } else {
                quizList.forEach(quiz => {
                    const option = document.createElement('option');
                    option.value = quiz.id; // The Quiz ID is the value
                    option.textContent = quiz.title; // The Name is the displayed text
                    selectElement.appendChild(option);
                });
                selectElement.disabled = false; // Enable dropdown now that it's populated
                startBuiltInQuizBtn.disabled = true; // Still disabled until user selects one
            }
        }


        // Functions
        function showScreen(screen) {
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            screen.classList.add('active');

            // Hide the header for all screens except welcome screen
            if (screen === welcomeScreen) {
                appHeader.classList.remove('hidden');
            } else {
                appHeader.classList.add('hidden');
            }

            // Hide the footer ONLY during loading and the actual questions
            if (screen === loadingScreen || screen === questionScreen) {
                appFooter.classList.add('hidden'); // Use the existing 'hidden' class
            } else {
                // Show footer on welcome, results, review, etc.
                appFooter.classList.remove('hidden');
            }
        }


        function proceedToQuiz() {
            if (enableSubmissionIdScreen) {
                // Show the Submission ID screen if enabled
                showScreen(webAppLinkScreen);
            } else {
                // Skip the Submission ID screen if disabled
                submissionId = null; // Ensure submissionId is null if skipping
                loadQuizQuestions(); // Load questions directly
            }
        }
        
        /**
         * Starts the quiz selected from the built-in dropdown menu.
         */
        function startBuiltInQuiz() {
            const name = nameInput.value.trim();
            const selectedQuizId = builtInQuizSelect.value; // Get ID from dropdown

            if (!name) {
                alert('Please enter your name. Your name is used solely for your quiz summary and is removed when you refresh the page.');
                return;
            }

            // Check if a valid quiz is selected (should be redundant due to button state, but safe)
            if (!selectedQuizId) {
                alert('Please select a quiz from the dropdown list.');
                return;
            }

            // *** Key Step: Set the main sheetIdInput's value ***
            // This allows us to reuse the existing loadQuizQuestions logic
            // which reads from sheetIdInput.
            sheetIdInput.value = selectedQuizId;

            // Set the student name
            studentName.textContent = name;
            
            // Call the central function to proceed
            proceedToQuiz(); 
        }

        
        // Modified startQuiz function to show Web App link screen
        function startCustomQuiz() {
            const name = nameInput.value.trim();
            const sheetId = sheetIdInput.value.trim();

            if (!name) {
                alert('Please enter your name. Your name is used solely for your quiz summary and is removed when you refresh the page.');
                return;
            }

            if (!sheetId) {
                alert('Please enter a Custom Quiz ID, or select a quiz from the dropdown list.');
                return;
            }

            // Set the student name
            studentName.textContent = name;
            
            // Call the central function to proceed
            proceedToQuiz(); 
        }

        // Function to validate Web App link
        // Function to validate Submission ID
        function validateWebAppLink() {
            const id = webAppLinkInput.value.trim();

            // Basic validation: enable OK button if the input is not empty
            // and doesn't contain characters typical of a full URL (like / or :).
            if (id && !id.includes('/') && !id.includes(':')) {
                confirmWebAppLinkBtn.disabled = false;
            } else {
                confirmWebAppLinkBtn.disabled = true;
            }
        }

        // Function to skip Result submission input
        function skipWebAppLink() {
            submissionId = null; // Set the ID to null
            loadQuizQuestions();
        }


        // Function to confirm Submission ID
        function confirmWebAppLink() {
            submissionId = webAppLinkInput.value.trim(); // Store the ID
            loadQuizQuestions();
        }

        // Function to load quiz questions
        function loadQuizQuestions() {
            showScreen(loadingScreen);
            
            const sheetId = sheetIdInput.value.trim();

            fetchQuestionData(sheetId)
                .then(data => {
                    if (data && data.length > 0) {
                        questions = data;
                        totalQuestions.textContent = questions.length;
                        totalQuestionsResult.textContent = questions.length;

                        // Extract quiz time limit from the first row if provided
                        if (questions[0].timeLimit && !isNaN(questions[0].timeLimit)) {
                            quizTimeLimit = parseInt(questions[0].timeLimit, 10);
                        }

                        // Preprocess MCQ questions to shuffle options only once
                        questions.forEach(question => {
                            if (question.type === 'MCQ') {
                                let options = (question.mcqOptions || '')
                                    .split('#')
                                    .map(option => option.trim())
                                    .filter(option => option !== '');
                                const correctAnswer = (question.answer || '').trim();
                                const shuffledOptions = shuffleArray(options);
                                const letters = Array.from({length: shuffledOptions.length}, (_, i) => String.fromCharCode(65 + i));
                                question.shuffledOptions = shuffledOptions.map((option, index) => ({
                                    letter: letters[index],
                                    option: option,
                                    isCorrect: option.toLowerCase().trim() === correctAnswer.toLowerCase().trim()
                                }));
                            }
                        });

                        // Initialize user answers array with empty objects instead of null
                        userAnswers = Array(questions.length).fill().map(() => ({
                            userAnswer: '',
                            isAnswered: false,
                            isCorrect: false
                        }));

                        // Start timer
                        startTime = new Date();
                        startTimer();

                        // Show first question
                        showQuestion(0);
                        showScreen(questionScreen);
                    } else {
                        alert('No questions found. Please ensure the Quiz ID is correct and try again.');
                        showScreen(welcomeScreen);
                    }
                })
                .catch(error => {
                    console.error('Error fetching questions:', error);
                    alert('Error loading questions. Please ensure the Quiz ID is correct and try again.');
                    showScreen(welcomeScreen);
                });
        }

        async function fetchQuestionData(sheetId) {
            const url = `https://docs.google.com/spreadsheets/d/${sheetId}/export?format=xlsx`;

            try {
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error('Failed to fetch spreadsheet');
                }

                const arrayBuffer = await response.arrayBuffer();
                const data = new Uint8Array(arrayBuffer);
                const workbook = XLSX.read(data, { type: 'array' });

                // Get the first sheet and convert to an array of arrays
                const firstSheetName = workbook.SheetNames[0];
                const worksheet = workbook.Sheets[firstSheetName];
                const rows = XLSX.utils.sheet_to_json(worksheet, { header: 1 });

                // If there are fewer than 2 rows, there is no data (since row 1 is header)
                if (!rows || rows.length < 2) {
                    return [];
                }

                // Define the expected column order, including the new "timeLimit" column
                const expectedOrder = [
                    'no',              // Question number
                    'question',        // Question text
                    'answer',          // Answer
                    'type',            // Question type
                    'mcqOptions',      // Multiple choice options
                    'readingMaterial', // Reading material
                    'hint',            // Hint
                    'explanation',     // Explanation
                    'timeLimit'        // Quiz time limit in minutes (new column)
                ];

                const questions = [];
                // Loop through rows starting from index 1 (row 2 in the sheet)
                for (let i = 1; i < rows.length; i++) {
                    const row = rows[i];
                    // Stop processing if the row is completely empty
                    if (row.every(cell => cell === undefined || cell === "")) {
                        break;
                    }
                    const rowData = {};
                    expectedOrder.forEach((key, index) => {
                        rowData[key] = row[index] || "";
                    });
                    questions.push(rowData);
                }

                return questions;
            } catch (error) {
                console.error('Error fetching or parsing the spreadsheet:', error);
                throw error;
            }
        }


        // NOTE: This function performs asynchronous operations (network, timeouts)
        // and returns a Promise. It should be called with await or .then().catch().
        async function submitQuizData(quizData) {
            // Check if a submission ID was provided
            if (!submissionId) {
                 console.log("No submission ID provided. Skipping submission.");
                 // Resolve with a specific status indicating skipped
                 return Promise.resolve('skipped');
            }

            // *** Check browser's online status first ***
            if (!navigator.onLine) {
                console.error("Submission aborted: Browser is offline.");
                // Reject immediately if the browser reports being offline
                return Promise.reject(new Error('Browser is offline. Submission failed.'));
            }
            // *** END ONLINE CHECK ***

            const fullWebAppUrl = WEB_APP_BASE_URL + submissionId + WEB_APP_URL_SUFFIX;
            console.log("Submitting to URL:", fullWebAppUrl); // Optional: for debugging

            // Return a new Promise to handle the asynchronous form submission
            return new Promise((resolve, reject) => {
                let form = null;
                let iframe = null;
                let timeoutId = null;
                let resolved = false; // Flag to prevent double resolution/rejection

                // Cleanup function (Updated for robustness)
                const cleanup = () => {
                    clearTimeout(timeoutId); // Clear the timeout regardless

                    // --- More Robust Removal ---
                    // Check if iframe exists and is still attached to the DOM before removing
                    if (iframe && iframe.parentNode) {
                        try {
                             iframe.parentNode.removeChild(iframe);
                             // console.log("Cleanup: Removed iframe."); // Optional log
                        } catch (e) {
                             // Log if removal failed (e.g., already removed by concurrent call)
                             console.warn("Could not remove iframe during cleanup (already removed?):", e.message);
                        }
                    } else if (iframe) {
                        // Optional log: If iframe exists but has no parent
                        // console.log("Cleanup: Iframe found but already detached.");
                    }

                    // Check if form exists and is still attached to the DOM before removing
                    if (form && form.parentNode) {
                         try {
                             form.parentNode.removeChild(form);
                             // console.log("Cleanup: Removed form."); // Optional log
                         } catch (e) {
                             // Log if removal failed
                             console.warn("Could not remove form during cleanup (already removed?):", e.message);
                         }
                    } else if (form) {
                        // Optional log: If form exists but has no parent
                        // console.log("Cleanup: Form found but already detached.");
                    }
                    // Nullify references after attempting removal
                    iframe = null;
                    form = null;
                     // --- End Robust Removal ---
                };


                try {
                    // Create an invisible form
                    form = document.createElement('form');
                    form.style.display = 'none';
                    form.method = 'POST';
                    form.action = fullWebAppUrl;
                    form.target = 'quizSubmitTarget'; // Use a fixed name or generate unique

                    // Add data as hidden inputs
                    for (const key in quizData) {
                        const input = document.createElement('input');
                        input.type = 'hidden';
                        input.name = key;
                        input.value = typeof quizData[key] === 'object'
                            ? JSON.stringify(quizData[key])
                            : quizData[key].toString();
                        form.appendChild(input);
                    }

                    // Create a hidden iframe to target the form submission
                    iframe = document.createElement('iframe');
                    iframe.name = 'quizSubmitTarget';
                    iframe.style.display = 'none';

                    // Handle response (iframe loaded something)
                    iframe.onload = () => {
                        if (resolved) return; // Prevent firing after timeout/error
                        resolved = true;
                        // NOTE: This load event can fire for success OR error pages (like 401, or offline page)
                        console.log("Submission iframe loaded (could be success or browser/server error page).");
                        cleanup(); // Call cleanup
                        // Resolve indicating the attempt finished via load event.
                        resolve('attempt_finished');
                    };

                    // Handle potential network errors on iframe itself (less common for POST)
                    iframe.onerror = (err) => {
                        if (resolved) return;
                        resolved = true;
                        console.error("Iframe loading error during submission:", err);
                        cleanup(); // Call cleanup
                        // Reject as this indicates a failure to even load the iframe target
                        reject(new Error('Iframe loading failed'));
                    };

                    // Set a timeout
                    timeoutId = setTimeout(() => {
                        if (resolved) return; // Prevent firing after onload/error
                        resolved = true;
                        console.log("Form submission timed out.");
                        cleanup(); // Call cleanup
                        // Treat timeout as failure for UI
                        reject(new Error('Submission timed out'));
                    }, 8000); // 8 seconds timeout

                    // Add elements to the DOM and submit
                    document.body.appendChild(iframe); // Add iframe first
                    document.body.appendChild(form);
                    form.submit();

                } catch (formError) {
                    // Catch errors during form/iframe setup
                    console.error("Error setting up form submission:", formError);
                    if (!resolved) { // Ensure cleanup happens if error occurred mid-setup
                         // Avoid calling cleanup explicitly here IF form/iframe weren't potentially added yet
                         // Let the variable checks handle null states. If they were added, subsequent events might call cleanup.
                         resolved = true; // Mark as resolved to prevent event handlers from running cleanup again
                         clearTimeout(timeoutId); // Still clear timeout
                    }
                    // Reject if the setup itself failed
                    reject(formError);
                }
            });
        }


        async function finishQuiz() {
                stopTimer();
                quizCompleted = true;

                // Get the notification element and reset its state
                const submissionNotification = document.getElementById('submissionNotification');
                submissionNotification.style.display = 'none';
                submissionNotification.textContent = '';
                submissionNotification.classList.remove('error'); // Remove error class if present

                // --- Calculate results (This part remains unchanged) ---
                const totalAttempted = userAnswers.filter(answer => answer && answer.isAnswered).length;
                const correct = userAnswers.filter(answer => answer && answer.isCorrect && answer.isAnswered).length;
                const incorrect = totalAttempted - correct;
                totalQuestionsAttempted.textContent = totalAttempted;
                correctAnswers.textContent = correct;
                correctAnswersCount.textContent = correct;
                incorrectAnswersCount.textContent = incorrect;
                const endTime = new Date();
                const elapsedMilliseconds = endTime - startTime;
                const elapsedSeconds = Math.floor(elapsedMilliseconds / 1000);
                const minutes = Math.floor(elapsedSeconds / 60);
                const seconds = elapsedSeconds % 60;
                const formattedTimeSpent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
                timeSpent.textContent = formattedTimeSpent;
                // --- End of results calculation ---


                // --- Submission Logic ---
                if (submissionId) {
                        const quizData = {
                                name: studentName.textContent,
                                quizId: sheetIdInput.value,
                                stats: buildStatsString(),
                                totalQuestions: questions.length,
                                questionsAttempted: totalAttempted,
                                correctAnswers: correct,
                                incorrectAnswers: incorrect,
                                timeSpent: formattedTimeSpent
                        };

                        // Wrap the submission attempt in try...catch
                        try {
                                // Attempt submission
                                const status = await submitQuizData(quizData); // status might be 'attempt_finished' or 'skipped'

                                // In this simple approach, DO NOTHING on success/resolve.
                                // Only show message on explicit failure caught below.
                                console.log(`Submission attempt finished with status: ${status}`);

                        } catch (error) {
                                // --- THIS IS WHERE WE SHOW THE ERROR ---
                                console.error("Submission failed:", error); // Log the actual error for debugging

                                // Display the generic error message to the user
                                submissionNotification.textContent = "Submission Error: Please take a screenshot of your results and inform your teacher.";
                                submissionNotification.classList.add('error'); // Add error styling
                                submissionNotification.style.display = 'block'; // Show the notification
                        }

                } else {
                        console.log("No submission ID entered, skipping submission.");
                        // No notification needed if submission was intentionally skipped.
                }

                // Show result screen (always happens)
                showScreen(resultScreen);
        }

        function goToHome() {
                // Reset app state
                questions = [];
                currentQuestion = 0;
                userAnswers = [];
                quizCompleted = false;

                if (builtInQuizSelect.options.length > 0) { // Check if options exist before setting index
                        builtInQuizSelect.selectedIndex = 0; // Reset dropdown to the default option
                }
                builtInQuizSelect.disabled = builtInQuizzes.length === 0; // Re-disable if no quizzes were loaded initially
                startBuiltInQuizBtn.disabled = true;  // Disable the start button

                nameInput.value = '';
                sheetIdInput.value = ''; // Reset custom quiz ID field as well
                quizTimeLimit = null;
                submissionId = null;
                webAppLinkInput.value = '';
                confirmWebAppLinkBtn.disabled = true;

                // Ensure the notification is hidden and reset
                const submissionNotification = document.getElementById('submissionNotification');
                if (submissionNotification) { // Check if element exists before manipulating
                        submissionNotification.style.display = 'none';
                        submissionNotification.textContent = '';
                        submissionNotification.classList.remove('error');
                }

                // Stop timer if running
                if (timerInterval) {
                        stopTimer();
                }

                // Show welcome screen
                showScreen(welcomeScreen);
        }

        
        // Utility function to shuffle an array (Fisher-Yates shuffle)
        function shuffleArray(array) {
            const arr = [...array];
            for (let i = arr.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [arr[i], arr[j]] = [arr[j], arr[i]];
            }
            return arr;
        }

        function showQuestion(index) {
            // Save current answer before moving to another question
            if (currentQuestion >= 0 && currentQuestion < questions.length && questions[currentQuestion] && questions[currentQuestion].type !== 'MCQ') {
                const currentInputValue = answerInput.value.trim();
                if (currentInputValue) {
                    saveUserAnswer(currentInputValue);
                }
            }

            if (index < 0) {
                index = 0;
            } else if (index >= questions.length) {
                index = questions.length - 1;
            }

            const question = questions[index];
            currentQuestion = index;
            currentQuestionNumber.textContent = index + 1;

            // Reset UI elements
            mcqOptions.innerHTML = '';
            typingAnswer.style.display = 'none';
            hintContainer.classList.remove('active');
            hintVisible = false;
            showHintBtn.textContent = 'Show Hint';

            // 1. Set question text using innerHTML (needed for KaTeX)
            // Ensure question.question is treated as a string
            const questionContent = String(question.question || '');
            questionText.innerHTML = questionContent; // Use innerHTML

            // 2. Tell KaTeX to render math within the questionText element
            // This uses the auto-render extension, which is simpler.
            // Make sure the DOM is updated before calling renderMathInElement.
            // Using setTimeout with 0ms delay often works to ensure this.
            setTimeout(() => {
                try {
                    if (window.renderMathInElement) {
                         window.renderMathInElement(questionText, {
                             // Optional: Configure delimiters if needed
                             delimiters: [
                                 {left: '$$', right: '$$', display: true},
                                 {left: '$', right: '$', display: false},
                                 {left: '\\(', right: '\\)', display: false},
                                 {left: '\\[', right: '\\]', display: true}
                             ],
                             // Optional: Configure error handling
                             throwOnError : false // Don't stop rendering on errors
                         });
                    } else {
                        console.warn("KaTeX auto-render extension not loaded.");
                    }
                } catch (error) {
                    console.error("Error rendering math with KaTeX:", error);
                     // Optionally display the raw text if rendering fails badly
                    questionText.innerHTML = questionContent; // Revert if needed
                }
            }, 0); // Delay ensures element is in DOM



            


            
            // Set reading material if available
            const rm = String(question.readingMaterial || "").trim().toLowerCase();
            if (!["", "none", "na"].includes(rm)) {
                readingMaterial.innerHTML = String(question.readingMaterial || ''); // Use innerHTML if math needed
                readingMaterial.style.display = 'block';
                // Also render math in reading material if needed
                setTimeout(() => {
                    if (window.renderMathInElement) {
                         window.renderMathInElement(readingMaterial, { /* options */ });
                    }
                }, 0);
            } else {
                readingMaterial.style.display = 'none';
                readingMaterial.innerHTML = ''; // Clear innerHTML
            }

            // Set hint text
            const hintValue = question.hint || '';
            hintText.textContent = hintValue && String(hintValue).trim() !== '' &&
                String(hintValue).toLowerCase() !== "none" ?
                hintValue : "No hints are provided for this question.";

            // Render question based on type
            if (question.type === 'MCQ') {
                renderMCQQuestion(question);
            } else {
                renderTypingQuestion(index);
            }
        }


        /**
         * Renders an MCQ question, including shuffling options and handling KaTeX rendering.
         * @param {object} question - The question object containing details like shuffledOptions.
         */
        function renderMCQQuestion(question) {
            // Clear any previous options displayed
            mcqOptions.innerHTML = '';

            // Ensure we have pre-shuffled options; fallback to empty array if not
            const optionsToRender = question.shuffledOptions || [];

            // Iterate through the shuffled options to create display elements
            optionsToRender.forEach((optionObj) => {
                // Create the main container div for the option
                const optionElement = document.createElement('div');
                optionElement.className = 'mcq-option';
                // Store the original raw option text (might include LaTeX) in a data attribute
                optionElement.dataset.option = optionObj.option;
                // Store the assigned letter (A, B, C...)
                optionElement.dataset.letter = optionObj.letter;

                // Create the element for the option letter (e.g., 'A')
                const letterElement = document.createElement('div');
                letterElement.className = 'mcq-option-letter';
                letterElement.textContent = optionObj.letter; // Display the letter

                // Create the element for the option's text content
                const textElement = document.createElement('div');
                textElement.className = 'mcq-option-text';

                // --- KEY CHANGE: Use innerHTML ---
                // Set the content using innerHTML so that HTML tags and LaTeX delimiters are parsed
                textElement.innerHTML = optionObj.option;

                // Append the letter and text elements to the main option container
                optionElement.appendChild(letterElement);
                optionElement.appendChild(textElement);

                // --- Check Selection State ---
                // If this option matches the previously saved user answer for the current question, mark it as selected
                if (userAnswers[currentQuestion] &&
                    userAnswers[currentQuestion].isAnswered && // Only check if an answer was actually saved
                    userAnswers[currentQuestion].userAnswer &&
                    userAnswers[currentQuestion].userAnswer.toLowerCase().trim() === optionObj.option.toLowerCase().trim()) {
                    optionElement.classList.add('selected');
                }

                // --- Add Click Listener ---
                // Add an event listener to handle when the user clicks on this option
                optionElement.addEventListener('click', () => {
                    // Remove the 'selected' class from all options first
                    document.querySelectorAll('#mcqOptions .mcq-option').forEach(el => el.classList.remove('selected'));
                    // Add the 'selected' class to the clicked option
                    optionElement.classList.add('selected');
                    // Save the user's answer (using the original option text, which might contain LaTeX)
                    saveUserAnswer(optionObj.option);
                });

                // Append the fully constructed option element to the main options container
                mcqOptions.appendChild(optionElement);

                // --- KEY CHANGE: Trigger KaTeX Rendering ---
                // Use setTimeout with 0ms delay to ensure the element is in the DOM
                // before attempting to render math inside it.
                setTimeout(() => {
                    try {
                        // Check if the KaTeX auto-render function is available
                        if (window.renderMathInElement) {
                            // Call KaTeX to render math within the text element of this specific option
                            window.renderMathInElement(textElement, {
                                // Define the delimiters KaTeX should look for
                                delimiters: [
                                    { left: '$$', right: '$$', display: true },  // Block math
                                    { left: '$', right: '$', display: false },   // Inline math
                                    { left: '\\(', right: '\\)', display: false }, // Inline math (LaTeX default)
                                    { left: '\\[', right: '\\]', display: true }   // Block math (LaTeX default)
                                ],
                                // Configuration to prevent one error from stopping all rendering
                                throwOnError: false
                            });
                        } else {
                            // Log a warning if KaTeX auto-render isn't loaded
                            console.warn("KaTeX auto-render function (renderMathInElement) not found while rendering MCQ options.");
                        }
                    } catch (error) {
                        // Log any errors that occur during KaTeX rendering for this option
                        console.error("Error rendering KaTeX in MCQ option:", error, "Raw Option Text:", optionObj.option);
                        // The raw LaTeX text will remain visible in the textElement if rendering fails
                    }
                }, 0); // End of setTimeout
            }); // End of forEach loop over options

            // Hide the typing answer input field as this is an MCQ question
            typingAnswer.style.display = 'none';
        }

        function renderTypingQuestion(index) {
            typingAnswer.style.display = 'block';

            // Set previous answer if exists
            if (userAnswers[index] && userAnswers[index].userAnswer) {
                answerInput.value = userAnswers[index].userAnswer;
            } else {
                answerInput.value = '';
            }

            answerInput.focus();
        }

        function saveUserAnswer(answer) {
            if (currentQuestion >= questions.length) return;

            const question = questions[currentQuestion];
            let userAnswer = String(answer || '').trim();
            let correctAnswer = String(question.answer || '').trim();

            // Check if input is empty
            if (userAnswer === '') {
                userAnswers[currentQuestion] = {
                    questionNo: question.no || currentQuestion + 1,
                    questionText: question.question || '',
                    userAnswer: '',
                    correctAnswer: correctAnswer,
                    isCorrect: false,
                    questionType: question.type || 'Text',
                    explanation: question.explanation || '',
                    isAnswered: false
                };
                return;
            }

            // Simple comparison for text answers
            let isCorrect = userAnswer.toLowerCase() === correctAnswer.toLowerCase();

            // For numeric values, try numeric comparison
            if (!isCorrect) {
                // Try to extract numeric values
                const userNum = parseFloat(userAnswer.replace(/[^\d.-]/g, ''));
                const correctNum = parseFloat(correctAnswer.replace(/[^\d.-]/g, ''));

                // If both are valid numbers, compare them with a small tolerance
                if (!isNaN(userNum) && !isNaN(correctNum)) {
                    isCorrect = Math.abs(userNum - correctNum) < 0.0001;
                }
            }

            // Save the answer
            userAnswers[currentQuestion] = {
                questionNo: question.no || currentQuestion + 1,
                questionText: question.question || '',
                userAnswer: userAnswer,
                correctAnswer: correctAnswer,
                isCorrect: isCorrect,
                questionType: question.type || 'Text',
                explanation: question.explanation || '',
                isAnswered: true
            };
        }

        function showPreviousQuestion() {
            if (currentQuestion === 0) {
                window.alert("This is the first question.");
                return;
            }
            showQuestion(currentQuestion - 1);
        }

        function showNextQuestion() {
            if (currentQuestion === questions.length - 1) {
                window.alert("This is the last question. If you have completed all questions, you can click the 'Submit All Answers' button to end the quiz.");
                return;
            }
            showQuestion(currentQuestion + 1);
        }

        function toggleHint() {
            hintVisible = !hintVisible;

            if (hintVisible) {
                hintContainer.classList.add('active');
                showHintBtn.textContent = 'Hide Hint';
            } else {
                hintContainer.classList.remove('active');
                showHintBtn.textContent = 'Show Hint';
            }
        }

        function submitAllAnswers() {
            // Save current answer before submitting
            if (questions[currentQuestion] && questions[currentQuestion].type !== 'MCQ') {
                const currentInputValue = answerInput.value.trim();
                if (currentInputValue) {
                    saveUserAnswer(currentInputValue);
                }
            }

            // Check if any questions are unanswered
            const unansweredQuestions = [];

            for (let i = 0; i < userAnswers.length; i++) {
                const answer = userAnswers[i];
                if (!answer || !answer.isAnswered) {
                    unansweredQuestions.push(i + 1);
                }
            }

            if (unansweredQuestions.length > 0) {
                const confirmSubmit = confirm(`You haven't answered question(s) ${unansweredQuestions.join(', ')}. Do you want to submit anyway?`);
                if (!confirmSubmit) {
                    showQuestion(unansweredQuestions[0] - 1);
                    return;
                }
            }

            // Finish the quiz
            finishQuiz();
        }

        function startTimer() {
            timerInterval = setInterval(() => {
                const now = new Date();
                const elapsedMilliseconds = now - startTime;
                const elapsedSeconds = Math.floor(elapsedMilliseconds / 1000);

                // If a quiz time limit is set, count down from that limit
                if (quizTimeLimit !== null) {
                    const totalSeconds = quizTimeLimit * 60;
                    const remainingSeconds = totalSeconds - elapsedSeconds;
                    if (remainingSeconds <= 0) {
                        timerValue.textContent = "00:00";
                        finishQuiz();
                    } else {
                        const minutes = Math.floor(remainingSeconds / 60);
                        const seconds = remainingSeconds % 60;
                        timerValue.textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
                    }
                } else {
                    // Default behavior: count up
                    const minutes = Math.floor(elapsedSeconds / 60);
                    const seconds = elapsedSeconds % 60;
                    timerValue.textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
                }
            }, 1000);
        }

        function stopTimer() {
            clearInterval(timerInterval);
        }

        // Function to build stats string for submission
        function buildStatsString() {
            return userAnswers.map((answer, index) => {
                const questionNum = index + 1;
                const result = answer.isAnswered ? 
                    (answer.isCorrect ? "right" : "wrong") : 
                    "unanswered";
                return `${questionNum}-${result}`;
            }).join(';');
        }


        function takeScreenshot() {
            const computedBg = window.getComputedStyle(resultScreen).backgroundColor;
            html2canvas(resultScreen, {
                backgroundColor: computedBg,
                scale: 2,
                useCORS: true,
                logging: false,
                allowTaint: true,
                letterRendering: true,
            }).then(canvas => {
                const link = document.createElement('a');
                link.download = `Quiz_Results_${studentName.textContent.replace(/\s+/g, '_')}_${new Date().toISOString().split('T')[0]}.png`;
                link.href = canvas.toDataURL('image/png', 1.0);
                link.click();
            });
        }

        /**
         * Displays the review screen, rendering each question, user's answer, correct answer,
         * and explanation. Handles KaTeX rendering for all relevant text content.
         */
        function showReviewScreen() {
            // Clear previous review content from the container
            reviewContainer.innerHTML = '';

            // --- Helper Function for KaTeX Rendering ---
            // This function encapsulates the logic to render math in a specific element,
            // including error handling and ensuring the element is ready in the DOM.
            const renderKatexInElement = (element) => {
                // Use setTimeout with 0ms delay. This pushes the rendering task
                // to the end of the current browser event loop cycle, ensuring
                // the 'element' has been fully added to the document's structure.
                setTimeout(() => {
                    try {
                        // Check if the KaTeX auto-render function is globally available
                        if (window.renderMathInElement) {
                            // Execute KaTeX rendering on the provided element
                            window.renderMathInElement(element, {
                                // Define the delimiters KaTeX should recognize for math expressions
                                delimiters: [
                                    { left: '$$', right: '$$', display: true },  // For block display math
                                    { left: '$', right: '$', display: false },   // For inline math
                                    { left: '\\(', right: '\\)', display: false }, // LaTeX standard inline
                                    { left: '\\[', right: '\\]', display: true }   // LaTeX standard block
                                ],
                                // Configuration to prevent errors in one math expression
                                // from halting the rendering of others on the page.
                                throwOnError: false
                            });
                        } else {
                            // Log a warning if KaTeX library seems unavailable
                            console.warn("KaTeX auto-render function (renderMathInElement) was not found during review screen generation.");
                        }
                    } catch (error) {
                        // Log any errors encountered during the KaTeX rendering process for this specific element
                        console.error("Error rendering KaTeX within a review screen element:", error, "Element's innerHTML:", element.innerHTML);
                        // Note: If rendering fails, the original text (including LaTeX markup) will remain visible.
                    }
                }, 0); // End of setTimeout callback
            }; // End of renderKatexInElement helper function

            // --- Iterate through User Answers to Build Review Items ---
            // Loop over the userAnswers array, which holds the results for each question.
            userAnswers.forEach((answer, index) => {
                // Retrieve the original question data corresponding to this answer's index
                const question = questions[index]; // Assumes 'questions' array is still accessible

                // --- Create the Main Container Div for this Question's Review ---
                const reviewItem = document.createElement('div');
                // Apply base styling class
                reviewItem.className = 'review-question';
                // Correctness class (correct/incorrect) will be added later based on the answer status

                // --- Create and Populate the Question Header Element ---
                const questionHeader = document.createElement('div');
                questionHeader.className = 'review-question-header';
                // Use innerHTML to allow potential LaTeX rendering within the question text.
                // Fallback text is provided if the question text is missing.
                questionHeader.innerHTML = `<strong>Question ${index + 1}:</strong> ${question.question || '[Question text not available]'}`;
                reviewItem.appendChild(questionHeader); // Add header to the review item

                // --- Create the Element for Displaying Answers ---
                const answerText = document.createElement('div');
                // Apply base styling class. Correctness class added below.
                answerText.className = 'review-answer';

                // --- Create and Populate the Explanation Element ---
                const explanationDiv = document.createElement('div');
                explanationDiv.className = 'review-explanation';
                let explanationContent = "No explanation was provided for this question."; // Default text
                // Check if an explanation exists, is a string, isn't empty, and isn't just "none" (case-insensitive)
                if (question.explanation && typeof question.explanation === 'string') {
                    const trimmedExplanation = question.explanation.trim();
                    if (trimmedExplanation !== '' && trimmedExplanation.toLowerCase() !== 'none') {
                        explanationContent = trimmedExplanation; // Use the valid explanation text
                    }
                }
                // Use innerHTML for potential LaTeX in the explanation.
                explanationDiv.innerHTML = `<strong>Explanation:</strong> ${explanationContent}`;


                // --- Determine Content Based on Whether the Question was Answered ---
                if (!answer || !answer.isAnswered) {
                    // Case: Question was NOT answered by the user
                    reviewItem.classList.add('incorrect'); // Style unanswered questions as incorrect
                    answerText.classList.add('incorrect');
                    // Display placeholders for user answer and show the correct answer. Use innerHTML for potential LaTeX.
                    answerText.innerHTML = `<strong>Your Answer:</strong> [Not Answered]<br><strong>Correct Answer:</strong> ${question.answer || '[Correct answer not available]'}`;
                } else {
                    // Case: Question WAS answered by the user
                    const isCorrect = answer.isCorrect; // Check if the stored answer was marked correct
                    // Apply appropriate styling based on correctness
                    reviewItem.classList.add(isCorrect ? 'correct' : 'incorrect');
                    answerText.classList.add(isCorrect ? 'correct' : 'incorrect');
                    // Display the user's answer. Use innerHTML for potential LaTeX.
                    answerText.innerHTML = `<strong>Your Answer:</strong> ${answer.userAnswer || '[Answer not recorded]'}`;
                    // If the answer was incorrect, also display the correct answer below the user's answer.
                    if (!isCorrect) {
                        // Use innerHTML for potential LaTeX in the correct answer.
                        answerText.innerHTML += `<br><strong>Correct Answer:</strong> ${answer.correctAnswer || '[Correct answer not available]'}`;
                    }
                }

                // --- Append Answer and Explanation Sections to the Review Item ---
                reviewItem.appendChild(answerText);
                reviewItem.appendChild(explanationDiv);

                // --- Append the Complete Review Item to the Main Review Container ---
                reviewContainer.appendChild(reviewItem);

                // --- Trigger KaTeX Rendering for Elements within this Item ---
                // Call the helper function for each part that might contain LaTeX.
                renderKatexInElement(questionHeader); // Render math in the question text
                renderKatexInElement(answerText);     // Render math in the user/correct answers
                renderKatexInElement(explanationDiv); // Render math in the explanation

            }); // --- End of forEach loop iterating through userAnswers ---

            // --- Activate the Review Screen ---
            // After building all review items, make the review screen visible.
            showScreen(reviewScreen);
        }

        function backToResults() {
            showScreen(resultScreen);
        }

  
        // Allow pressing Enter to submit answers for typing questions
        answerInput.addEventListener('keypress', function (event) {
            if (event.key === 'Enter') {
                // Save the answer before navigating
                saveUserAnswer(answerInput.value);

                const nextIndex = currentQuestion + 1;
                if (nextIndex < questions.length) {
                    showQuestion(nextIndex);
                }
            }
        });

        
        document.addEventListener('DOMContentLoaded', () => {
            loadBuiltInQuizList();
            
            const pv = document.getElementById('pageviews');

            if (pv !== null) {
                // Strip trailing slash (if any) so the path matches GoatCounter
                const uri = location.pathname.replace(/\/$/, '');
                // Build the JSON endpoint URL for your domain
                const url = `https://linsnotes.goatcounter.com/counter/${encodeURIComponent(uri)}.json`;

                fetch(url)
                    .then((response) => response.json())
                    .then((data) => {
                        // 'data.count' comes back as a string with possible whitespace
                        const count = data.count.replace(/\s/g, '');
                        // Format it with commas, etc.
                        pv.innerText = new Intl.NumberFormat().format(count);
                        pv.classList.remove('loading');
                    })
                    .catch((error) => {
                        // Fallback if something goes wrong
                        pv.innerText = '1';
                        pv.classList.remove('loading');
                    });
            }
        });
    </script>
</body>

</html>
